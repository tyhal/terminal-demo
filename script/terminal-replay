#!/usr/bin/env python3
import os
import pty
import signal
import subprocess
import threading
import time
import string
import sys
import select
import re
import fcntl, termios, struct
from functools import reduce

prompt_regex = re.compile(os.getenv("PROMPT_START","‚ùØ|#"))

if len(sys.argv) != 2:
    print(f"Usage: {sys.argv[0]} <file_path>")
    sys.exit(1)
file_path = sys.argv[1]

# Slow down when tabbing or hitting enter
attention_chars = ['\n']
typing_chars = string.ascii_letters + string.digits

# Load the replay data
with open(file_path, 'r') as f:
    data = f.read()

special = [
    ('\\t','\t'),
    ('\\b','\b')
]

data = reduce(lambda txt, rep: txt.replace(*rep), special, data)

data = data.replace('\\t', '\t')

# Create a pseudo-terminal and spawn zsh
def get_winsize(fd):
    packed = fcntl.ioctl(fd, termios.TIOCGWINSZ, struct.pack("HHHH", 0, 0, 0, 0))
    rows, cols, _, _ = struct.unpack("HHHH", packed)
    return rows, cols

def spawn_shell():
    rows, cols = get_winsize(sys.stdout.fileno())

    pid, fd = pty.fork()
    if pid == 0:
        env = os.environ.copy()
        env['LINES'] = str(rows)
        env['COLUMNS'] = str(cols)
        os.execve('/bin/zsh', ['zsh'], env)
    else:
        winsize = struct.pack("HHHH", rows, cols, 0, 0)
        fcntl.ioctl(fd, termios.TIOCSWINSZ, winsize)
    return pid, fd


def get_child_pids(ppid):
    try:
        # ps -o pid,ppid -ax shows PID and PPID of all processes
        output = subprocess.check_output(['ps', '-o', 'pid=,ppid=', '-ax'], text=True)
    except Exception:
        return []

    children = []
    for line in output.strip().splitlines():
        try:
            pid_str, ppid_str = line.strip().split(None, 1)
            if int(ppid_str) == ppid:
                children.append(int(pid_str))
        except ValueError:
            continue
    return children

def wait_for_descendants(ppid, timeout=None, poll_interval=0.5):
    start = time.time()
    while True:
        if timeout and (time.time() - start > timeout):
            break
        descendants = get_child_pids(ppid)
        if not descendants:
            break
        time.sleep(poll_interval)

pid, fd = spawn_shell()
pgid = os.getpgid(pid)

# Thread to read output from the shell
stop_event = threading.Event()
prompt_found_event = threading.Event()

def read_output():
    buffer = ''
    while not stop_event.is_set():
        rlist, _, _ = select.select([fd], [], [], 0.01)
        if fd in rlist:
            try:
                output = os.read(fd, 1024).decode('utf-8', errors='ignore')
                if output:
                    sys.stdout.write(output)
                    sys.stdout.flush()
                    buffer += output
                    if prompt_regex.search(buffer):
                        prompt_found_event.set()
                        buffer = ''
            except OSError:
                break

t = threading.Thread(target=read_output, daemon=True)
t.start()
prompt_found_event.wait()

# Send characters to shell with delays
for char in data:
    if char in typing_chars:
        time.sleep(0.1)
    elif char == ' ':
        time.sleep(0.2)
    elif char == '\t':
        time.sleep(1)
    elif char == '\n':
        time.sleep(2)
    else:
        time.sleep(0.3)

    os.write(fd, char.encode())

    if char == '\n':
        wait_for_descendants(pid)
        prompt_found_event.wait()
        # TODO only wait longer if there was more output
        time.sleep(2)

    if char == '\t':
        time.sleep(1)

# kill the writer
os.kill(pid, signal.SIGHUP)
os.waitpid(pid, 0)
# kill the reader
stop_event.set()
t.join()
# close the fd
os.close(fd)

